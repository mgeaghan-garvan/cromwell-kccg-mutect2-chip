#!/usr/bin/env python3

# This script is used to fix the INFO field of the VCF file generated by ANNOVAR
#
# ANNOVAR writes malformed INFO fields by allowing commas within value strings, and
# by adding duplicate keys when either multi-allelic variants are annotated, or when
# ANNOVAR is run multiple times.
#
# This script first removes commas from the value strings, and then merges the values
# of duplicate keys into a single key-value pair, with the values separated by commas.

import sys
import os


def print_usage_and_exit():
    print('Usage: fix_info_field.py <input.vcf> [<output.vcf>]')
    sys.exit(1)


def fix_info_field(info_field: str = '') -> str:
    # Split the INFO field by semicolons into a list of key-value pairs
    info_field_list = info_field.split(';')
    # Find the indices of the ANNOVAR_DATE and ALLELE_END tags (could be multiple)
    annovar_start_indices = [i for i, s in enumerate(info_field_list) if s.startswith('ANNOVAR_DATE=')]
    annovar_end_indices = [i for i, s in enumerate(info_field_list) if s == 'ALLELE_END']
    # If the ANNOVAR_DATE and ALLELE_END tags are not balanced, raise an error
    if len(annovar_start_indices) != len(annovar_end_indices):
        raise ValueError(f'Error: ANNOVAR_DATE and ALLELE_END tags are not balanced')
    # Replace commas in the value strings with the hex code for a comma
    # Merge the values of duplicate keys into a single key-value pair
    new_info_field_list = []
    annovar_dict = {}
    for i, key_value in enumerate(info_field_list):
        # Don't modify non-ANNOVAR annotations
        if not any([i in range(start, end + 1) for start, end in zip(annovar_start_indices, annovar_end_indices)]):
            new_info_field_list.append(key_value)
            continue
        # Split the key-value pair by the equals sign
        key_value = key_value.split('=')
        # Handle malformed key-value pairs
        if len(key_value) > 2 or len(key_value) < 1:
            raise ValueError(f'Error: malformed key-value pair: {info_field_list[i]}')
        # Handle keys with no value
        elif len(key_value) == 1:
            key = key_value[0]
            new_value = None
        # Handle keys with a value
        else:
            key, value = key_value
            new_value = value.replace(',', '\\x2c')
        # Add the key-value pair to the dictionary
        if key not in annovar_dict:
            annovar_dict[key] = []
        # Handle keys with values
        if new_value is not None:
            annovar_dict[key].append(new_value)
    # Join the values of each key with a comma
    annovar_dict = {key: ','.join(values) for key, values in annovar_dict.items()}
    # Remove the bookend keys
    annovar_start = annovar_dict.pop('ANNOVAR_DATE', '.')
    annovar_end = annovar_dict.pop('ALLELE_END')
    # Convert the dictionary back into a list of key-value pairs
    new_info_field_list.append(f'ANNOVAR_DATE={annovar_start}')
    new_info_field_list.extend([
        f'{key}={value}' if value else key for key, value in annovar_dict.items()
    ])
    new_info_field_list.append('ALLELE_END')
    # Join the list of key-value pairs back into a single string and return
    new_info_field = ';'.join(new_info_field_list)
    return new_info_field


def fix_vcf_line(line: list[str] = []) -> list[str]:
    # If the line does not contain the INFO field, return the line as is
    if len(line) < 8:
        return line
    # Fix the INFO field and return the line with the new INFO field
    info = line[7]
    new_info = fix_info_field(info)
    return line[:7] + [new_info] + line[8:]


if __name__ == '__main__':
    # Check the command-line arguments
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print_usage_and_exit()
    elif '-h' in sys.argv or '--help' in sys.argv:
        print_usage_and_exit()

    # Check input file exists
    input_file = sys.argv[1]
    if not os.path.exists(input_file) or not os.path.isfile(input_file):
        print('Error: input file does not exist or is not a file')
        print_usage_and_exit()

    # Check output file does not exist if specified
    output_file = None
    if len(sys.argv) == 3:
        output_file = sys.argv[2]
        if os.path.exists(output_file):
            print('Error: output file already exists')
            print_usage_and_exit()

    with open(input_file, 'r') as f:
        # output_list and buffer are used to write the output in chunks
        output_list = []
        buffer = 1000
        # Open the output file if required
        if output_file is not None:
            o = open(output_file, 'w')
        # Process each line in the input file
        for i, line in enumerate(f):
            # If the line starts with a #, don't modify it
            if line.startswith('#'):
                new_line = line.strip()
            else:
                # Split the line by tabs and fix the INFO field
                line_list = line.strip().split('\t')
                new_line_list = fix_vcf_line(line_list)
                new_line = '\t'.join(new_line_list)
            # Add the new line to output_list or print to stdout
            if output_file is not None:
                output_list.append(new_line)
            else:
                print(new_line)
            # If writing to a file, write the output in chunks
            if output_file is not None and (i + 1) % buffer == 0:
                o.write('\n'.join(output_list) + '\n')
                output_list = []
        # Write any remaining output to the file and close the file
        if output_file is not None:
            if len(output_list) > 0:
                o.write('\n'.join(output_list) + '\n')
            o.close()
